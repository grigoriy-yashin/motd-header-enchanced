#!/bin/bash
###############################################################################
# MOTD: ASCII logo + dynamic sysinfo entries with cache logic from 50-landscape
###############################################################################

WIDTH=30
ASSET_LOGO_PATH="/etc/update-motd.d/assets/logo.txt"
CACHE="/var/lib/landscape/landscape-sysinfo.cache"

ENTRIES=()
ENTRIES+=("Welcome to $(lsb_release -d | cut -f2-)")
ENTRIES+=("($(uname -o) $(uname -r) $(uname -m))")
ENTRIES+=(" ")

STATIC_COUNT=${#ENTRIES[@]}

# === 1. Obtain system info from landscape-sysinfo ===
if [ -x /usr/bin/landscape-sysinfo ]; then
    HAS_CACHE="FALSE"
    CACHE_NEEDS_UPDATE="FALSE"

    [ -r "$CACHE" ] && HAS_CACHE="TRUE"
    [ -z "$(find "$CACHE" -newermt 'now-1 minutes' 2> /dev/null)" ] && CACHE_NEEDS_UPDATE="TRUE"

    if [ "$HAS_CACHE" = "TRUE" ] && [ "$CACHE_NEEDS_UPDATE" = "FALSE" ]; then
        SYSINFO_OUTPUT=$(cat "$CACHE")
    else
        SYSINFO_OUTPUT=""
        [ -f /etc/default/locale ] && . /etc/default/locale
        export LANG
        CORES=$(grep -c ^processor /proc/cpuinfo 2>/dev/null)
        [ "$CORES" -eq "0" ] && CORES=1
        THRESHOLD="${CORES:-1}.0"

        if [ "$(echo "$(cut -f1 -d ' ' /proc/loadavg) < $THRESHOLD" | bc)" -eq 1 ]; then
            SYSINFO_OUTPUT=$(printf "\n System information as of %s\n\n%s\n" \
                "$(/bin/date)" \
                "$(/usr/bin/landscape-sysinfo)")
            echo "$SYSINFO_OUTPUT" 2>/dev/null >"$CACHE" || true
            chmod 0644 "$CACHE" 2>/dev/null || true
        else
            SYSINFO_OUTPUT=$(printf "\n System information disabled due to load higher than %s\n" "$THRESHOLD")
            if [ "$HAS_CACHE" = "TRUE" ]; then
                if ! grep -q "System information as of" "$CACHE" 2>/dev/null; then
                    echo "$SYSINFO_OUTPUT" 2>/dev/null >"$CACHE" || true
                    chmod 0644 "$CACHE" 2>/dev/null || true
                else
                    SYSINFO_OUTPUT=$(cat "$CACHE")
                fi
            fi
        fi
    fi

    wanted_keys=(
        "System load:"
        "Usage of /:"
        "Memory usage:"
        "Swap usage:"
        "Processes:"
        "Users logged in:"
        "IPv4 address for"
        "Temperature:"
    )

    while IFS= read -r line; do
        field_positions=()
        for key in "${wanted_keys[@]}"; do
            pos=$(awk -v a="$line" -v b="$key" 'BEGIN{print index(a,b)}')
            if [ "$pos" -gt 0 ]; then
                field_positions+=("$pos:$key")
            fi
        done

        if [ "${#field_positions[@]}" -eq 1 ]; then
            key=${field_positions[0]#*:}
            val=${line#*$key}
            ENTRIES+=("$key$val")
        elif [ "${#field_positions[@]}" -gt 1 ]; then
            IFS=$'\n' sorted=($(printf '%s\n' "${field_positions[@]}" | sort -n))
            for i in "${!sorted[@]}"; do
                pos=${sorted[$i]%%:*}
                key=${sorted[$i]#*:}
                start=$pos
                if [ $i -lt $((${#sorted[@]} - 1)) ]; then
                    next_pos=${sorted[$((i+1))]%%:*}
                    length=$((next_pos - pos))
                    chunk=${line:$start-1:$length}
                else
                    chunk=${line:$start-1}
                fi
                trimmed=$(echo "$chunk" | sed -E 's/^[[:space:]]+//;s/[[:space:]]+$//')
                ENTRIES+=("$trimmed")
            done
        fi
    done <<< "$SYSINFO_OUTPUT"
fi

# === 2. Load logo ===
if [ ! -f "$ASSET_LOGO_PATH" ]; then
    echo "ERROR: Logo file not found at $ASSET_LOGO_PATH"
    exit 1
fi

IFS=$'\n' read -r -d '' -a LOGO_LINES < "$ASSET_LOGO_PATH"
LOGO_HEIGHT=${#LOGO_LINES[@]}
LOGO_WIDTH=$(printf '%s\n' "${LOGO_LINES[@]}" | awk '{print length}' | sort -nr | head -n1)
ENTRIES_HEIGHT=${#ENTRIES[@]}

# === 3. Wide logo: header + logo + two-column sysinfo ===
if [ "$LOGO_WIDTH" -gt "$WIDTH" ]; then
    [ -r /etc/lsb-release ] && . /etc/lsb-release
    if [ -z "$DISTRIB_DESCRIPTION" ] && [ -x /usr/bin/lsb_release ]; then
        DISTRIB_DESCRIPTION=$(lsb_release -s -d)
    fi
    printf "Welcome to %s (%s %s %s)\n\n" "$DISTRIB_DESCRIPTION" "$(uname -o)" "$(uname -r)" "$(uname -m)"

    printf '%s\n' "${LOGO_LINES[@]}"
    echo

    sys_entries=("${ENTRIES[@]:$STATIC_COUNT}")

    if [ "${#sys_entries[@]}" -gt 0 ]; then
        printf "\nSystem information as of %s\n\n" "$(/bin/date)"
    fi

    half=$(( (${#sys_entries[@]} + 1) / 2 ))
    LEFT=("${sys_entries[@]:0:$half}")
    RIGHT=("${sys_entries[@]:$half}")

    parse_column() {
        local entries=("$@")
        local keys=()
        local values=()
        local max_key=0

        for line in "${entries[@]}"; do
            key="${line%%:*}:"
            val="$(echo "${line#*:}" | sed 's/^[[:space:]]*//')"
            keys+=("$key")
            values+=("$val")
            [ ${#key} -gt $max_key ] && max_key=${#key}
        done

        echo "$(IFS=$'\n'; echo "${keys[*]}")" > /tmp/keys
        echo "$(IFS=$'\n'; echo "${values[*]}")" > /tmp/vals
        echo "$max_key" > /tmp/max
    }

    parse_column "${LEFT[@]}"
    LEFT_KEYS=($(< /tmp/keys))
    LEFT_VALUES=($(< /tmp/vals))
    LEFT_WIDTH=$(< /tmp/max)

    parse_column "${RIGHT[@]}"
    RIGHT_KEYS=($(< /tmp/keys))
    RIGHT_VALUES=($(< /tmp/vals))
    RIGHT_WIDTH=$(< /tmp/max)

    for i in $(seq 0 $((half - 1))); do
        printf "  %-*s %s" "$LEFT_WIDTH" "${LEFT_KEYS[$i]}" "${LEFT_VALUES[$i]}"
        if [ -n "${RIGHT_KEYS[$i]}" ]; then
            printf "   %-*s %s" "$RIGHT_WIDTH" "${RIGHT_KEYS[$i]}" "${RIGHT_VALUES[$i]}"
        fi
        echo
    done
    exit 0
fi

# === 4. Tall logo: side-by-side with entries ===
if [ "$LOGO_HEIGHT" -ge "$ENTRIES_HEIGHT" ]; then
    for i in "${!LOGO_LINES[@]}"; do
        if [ $i -lt "$ENTRIES_HEIGHT" ]; then
            printf "%s   %s\n" "${LOGO_LINES[$i]}" "${ENTRIES[$i]}"
        else
            printf "%s\n" "${LOGO_LINES[$i]}"
        fi
    done
    exit 0
fi

# === 5. Short logo: header + logo + two-column sysinfo ===
[ -r /etc/lsb-release ] && . /etc/lsb-release
if [ -z "$DISTRIB_DESCRIPTION" ] && [ -x /usr/bin/lsb_release ]; then
    DISTRIB_DESCRIPTION=$(lsb_release -s -d)
fi

printf "Welcome to %s (%s %s %s)\n\n" "$DISTRIB_DESCRIPTION" "$(uname -o)" "$(uname -r)" "$(uname -m)"
printf '%s\n' "${LOGO_LINES[@]}"

sys_entries=("${ENTRIES[@]:$STATIC_COUNT}")

if [ "${#sys_entries[@]}" -gt 0 ]; then
    printf "\nSystem information as of %s\n\n" "$(/bin/date)"
fi

half=$(( (${#sys_entries[@]} + 1) / 2 ))
LEFT=("${sys_entries[@]:0:$half}")
RIGHT=("${sys_entries[@]:$half}")

parse_column() {
    local entries=("$@")
    local keys=()
    local values=()
    local max_key=0

    for line in "${entries[@]}"; do
        key="${line%%:*}:"
        val="$(echo "${line#*:}" | sed 's/^[[:space:]]*//')"
        keys+=("$key")
        values+=("$val")
        [ ${#key} -gt $max_key ] && max_key=${#key}
    done

    echo "$(IFS=$'\n'; echo "${keys[*]}")" > /tmp/keys
    echo "$(IFS=$'\n'; echo "${values[*]}")" > /tmp/vals
    echo "$max_key" > /tmp/max
}

parse_column "${LEFT[@]}"
LEFT_KEYS=($(< /tmp/keys))
LEFT_VALUES=($(< /tmp/vals))
LEFT_WIDTH=$(< /tmp/max)

parse_column "${RIGHT[@]}"
RIGHT_KEYS=($(< /tmp/keys))
RIGHT_VALUES=($(< /tmp/vals))
RIGHT_WIDTH=$(< /tmp/max)

for i in $(seq 0 $((half - 1))); do
    printf "  %-*s %s" "$LEFT_WIDTH" "${LEFT_KEYS[$i]}" "${LEFT_VALUES[$i]}"
    if [ -n "${RIGHT_KEYS[$i]}" ]; then
        printf "   %-*s %s" "$RIGHT_WIDTH" "${RIGHT_KEYS[$i]}" "${RIGHT_VALUES[$i]}"
    fi
    echo
done
exit 0