#!/bin/bash
###############################################################################
# MOTD script: ASCII logo + system info entries (landscape-sysinfo based)
# Handles wide/short logo logic, dynamic entry count, clean formatting, and
# mirrors original 50-landscape-sysinfo cache behavior.
###############################################################################

WIDTH=30
ASSET_LOGO_PATH="/etc/update-motd.d/assets/logo.txt"
CACHE="/var/lib/landscape/landscape-sysinfo.cache"

ENTRIES=()
ENTRIES+=("Welcome to $(lsb_release -d | cut -f2-)")
ENTRIES+=("($(uname -o) $(uname -r) $(uname -m))")
ENTRIES+=(" ")

STATIC_COUNT=${#ENTRIES[@]}

# =============================
# 1. Parse landscape-sysinfo
# =============================
if [ -x /usr/bin/landscape-sysinfo ]; then
    HAS_CACHE="FALSE"
    CACHE_NEEDS_UPDATE="FALSE"

    [ -r "$CACHE" ] && HAS_CACHE="TRUE"
    [ -z "$(find "$CACHE" -newermt 'now-1 minutes' 2>/dev/null)" ] && CACHE_NEEDS_UPDATE="TRUE"

    if [ "$HAS_CACHE" = "TRUE" ] && [ "$CACHE_NEEDS_UPDATE" = "FALSE" ]; then
        SYSINFO_OUTPUT=$(cat "$CACHE")
    else
        SYSINFO_OUTPUT=""
        [ -f /etc/default/locale ] && . /etc/default/locale
        export LANG
        CORES=$(grep -c ^processor /proc/cpuinfo 2>/dev/null)
        [ "$CORES" -eq "0" ] && CORES=1
        THRESHOLD="${CORES:-1}.0"

        if [ "$(echo "$(cut -f1 -d ' ' /proc/loadavg) < $THRESHOLD" | bc)" -eq 1 ]; then
            SYSINFO_OUTPUT=$(printf "\n System information as of %s\n\n%s\n" \
                "$(${DATE_CMD:-/bin/date})" \
                "$(${LANDSCAPE_CMD:-/usr/bin/landscape-sysinfo)}")
            echo "$SYSINFO_OUTPUT" > "$CACHE" 2>/dev/null || true
            chmod 0644 "$CACHE" 2>/dev/null || true
        else
            SYSINFO_OUTPUT=$(printf "\n System information disabled due to load higher than %s\n" "$THRESHOLD")
            if [ "$HAS_CACHE" = "TRUE" ]; then
                if ! grep -q "System information as of" "$CACHE" 2>/dev/null; then
                    echo "$SYSINFO_OUTPUT" > "$CACHE" 2>/dev/null || true
                    chmod 0644 "$CACHE" 2>/dev/null || true
                else
                    SYSINFO_OUTPUT=$(cat "$CACHE")
                fi
            fi
        fi
    fi

    # Parse output lines into key-value pairs based on known sysinfo labels
    wanted_keys=(
        "System load:"
        "Usage of /:"
        "Memory usage:"
        "Swap usage:"
        "Processes:"
        "Users logged in:"
        "IPv4 address for"
        "Temperature:"
    )

    while IFS= read -r line; do
        field_positions=()
        for key in "${wanted_keys[@]}"; do
            pos=$(awk -v a="$line" -v b="$key" 'BEGIN{print index(a,b)}')
            [ "$pos" -gt 0 ] && field_positions+=("$pos:$key")
        done

        if [ ${#field_positions[@]} -eq 1 ]; then
            key=${field_positions[0]#*:}
            val=${line#*$key}
            ENTRIES+=("$key$val")
        elif [ ${#field_positions[@]} -gt 1 ]; then
            IFS=$'\n' sorted=($(printf '%s\n' "${field_positions[@]}" | sort -n))
            for i in "${!sorted[@]}"; do
                pos=${sorted[$i]%%:*}
                key=${sorted[$i]#*:}
                start=$pos
                if [ $i -lt $((${#sorted[@]} - 1)) ]; then
                    next_pos=${sorted[$((i+1))]%%:*}
                    length=$((next_pos - pos))
                    chunk=${line:$start-1:$length}
                else
                    chunk=${line:$start-1}
                fi
                trimmed=$(echo "$chunk" | sed -E 's/^[[:space:]]+//;s/[[:space:]]+$//')
                ENTRIES+=("$trimmed")
            done
        fi
    done <<< "$SYSINFO_OUTPUT"
fi

# =============================
# 2. Read ASCII logo
# =============================
if [ ! -f "$ASSET_LOGO_PATH" ]; then
    echo "ERROR: Logo file not found at $ASSET_LOGO_PATH"
    exit 1
fi
IFS=$'\n' read -r -d '' -a LOGO_LINES < "$ASSET_LOGO_PATH"
LOGO_HEIGHT=${#LOGO_LINES[@]}
LOGO_WIDTH=$(printf '%s\n' "${LOGO_LINES[@]}" | awk '{print length}' | sort -nr | head -n1)
ENTRIES_HEIGHT=${#ENTRIES[@]}

# =============================
# 3. Format and print aligned entries
# =============================
print_aligned_entries() {
    local -a entries=()
    local -a keys=()
    local -a values=()
    local key_width=0
    local value_width=0

    entries=("${@}")
    for line in "${entries[@]}"; do
        key="${line%%:*}:"
        value="$(echo "${line#*:}" | sed 's/^[[:space:]]*//')"
        keys+=("$key")
        values+=("$value")
        [ ${#key} -gt $key_width ] && key_width=${#key}
        [ ${#value} -gt $value_width ] && value_width=${#value}
    done

    align_entries=()
    for i in "${!keys[@]}"; do
        key_pad=$(printf "%-${key_width}s" "${keys[$i]}")
        value_pad=$(printf "%-${value_width}s" "${values[$i]}")
        align_entries+=("$key_pad $value_pad")
    done

    local half=$(( (${#align_entries[@]} + 1) / 2 ))
    local -a col1=("${align_entries[@]:0:$half}")
    local -a col2=("${align_entries[@]:$half}")

    local max_len=$(printf '%s\n' "${col1[@]}" | awk '{print length}' | sort -nr | head -n1)
    for i in $(seq 0 $((half - 1))); do
        printf "%-*s   %s\n" "$max_len" "${col1[$i]}" "${col2[$i]}"
    done
}

# =============================
# 4. Decide display case
# =============================
if [ "$LOGO_WIDTH" -gt "$WIDTH" ]; then
    [ -r /etc/lsb-release ] && . /etc/lsb-release
    [ -z "$DISTRIB_DESCRIPTION" ] && DISTRIB_DESCRIPTION=$(lsb_release -s -d 2>/dev/null)

    printf "Welcome to %s (%s %s %s)\n\n" "$DISTRIB_DESCRIPTION" "$(uname -o)" "$(uname -r)" "$(uname -m)"
    printf "%s\n" "${LOGO_LINES[@]}"
    echo
    print_aligned_entries "${ENTRIES[@]:$STATIC_COUNT}"
    exit 0
fi

if [ "$LOGO_HEIGHT" -ge "$ENTRIES_HEIGHT" ]; then
    for i in "${!LOGO_LINES[@]}"; do
        if [ $i -lt "$ENTRIES_HEIGHT" ]; then
            printf "%s   %s\n" "${LOGO_LINES[$i]}" "${ENTRIES[$i]}"
        else
            printf "%s\n" "${LOGO_LINES[$i]}"
        fi
    done
    exit 0
fi

[ -r /etc/lsb-release ] && . /etc/lsb-release
[ -z "$DISTRIB_DESCRIPTION" ] && DISTRIB_DESCRIPTION=$(lsb_release -s -d 2>/dev/null)

printf "Welcome to %s (%s %s %s)\n\n" "$DISTRIB_DESCRIPTION" "$(uname -o)" "$(uname -r)" "$(uname -m)"
printf "%s\n" "${LOGO_LINES[@]}"

echo
print_aligned_entries "${ENTRIES[@]:$STATIC_COUNT}"
exit 0
